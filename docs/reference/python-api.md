# Python API Reference

Complete autogenerated reference for the Python CEL library.

## Functions

::: cel.evaluate


## Classes  

### Context

**A class for managing evaluation context with variables and custom functions.**

The Context class provides more control over the evaluation environment than simple dictionary context. It allows you to:

- Add variables with type checking
- Register custom Python functions  
- Manage complex evaluation scenarios

```python
from cel import evaluate, Context

# Basic usage
context = Context()
context.add_variable("name", "Alice")
context.add_variable("age", 30)

result = evaluate("name + ' is ' + string(age)", context)
# → "Alice is 30"
assert result == "Alice is 30"
```

#### Methods

##### add_variable(name: str, value: Any) -> None

Add a variable to the context.

**Parameters:**
- `name`: Variable name (must be valid CEL identifier)
- `value`: Variable value (will be converted to appropriate CEL type)

**Example:**
```python
from cel import Context, evaluate

context = Context()
context.add_variable("user_id", "123")
context.add_variable("permissions", ["read", "write"])
context.add_variable("config", {"debug": True, "port": 8080})

# Verify the variables are accessible
evaluate("user_id", context)
# → "123"
evaluate("size(permissions)", context)
# → 2
evaluate("config.debug", context)
# → True
assert evaluate("user_id", context) == "123"
assert evaluate("size(permissions)", context) == 2
assert evaluate("config.debug", context) == True
```

##### update(variables: Dict[str, Any]) -> None

Add multiple variables at once.

**Parameters:**
- `variables`: Dictionary of variable names to values

**Example:**
```python
from cel import Context, evaluate

context = Context()
context.update({
    "user_id": "123",
    "role": "admin", 
    "permissions": ["read", "write", "delete"]
})

# Verify the batch update worked
evaluate("user_id", context)
# → "123"
evaluate("role", context)
# → "admin"
evaluate("size(permissions)", context)
# → 3
assert evaluate("user_id", context) == "123"
assert evaluate("role", context) == "admin"
assert evaluate("size(permissions)", context) == 3
```

##### add_function(name: str, func: Callable) -> None

Register a Python function for use in CEL expressions.

**Parameters:**
- `name`: Function name as it will appear in CEL expressions
- `func`: Python function to register

**Requirements for functions:**
- Should handle type conversions appropriately
- Should raise meaningful exceptions for invalid inputs
- Must be callable from the Python environment

**Example:**
```python
from cel import Context, evaluate

def validate_email(email):
    import re
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

context = Context()
context.add_function("validate_email", validate_email)

evaluate('validate_email("user@example.com")', context)
# → True

# Test invalid email
evaluate('validate_email("invalid-email")', context)
# → False
result = evaluate('validate_email("user@example.com")', context)
assert result == True

result = evaluate('validate_email("invalid-email")', context)
assert result == False
```

---

## Type System

### CEL to Python Type Mapping

This table shows how CEL types are converted to Python types when expressions are evaluated:

| CEL Type | CEL Spec | Python Type | Example CEL | Python Result |
|----------|----------|-------------|-------------|---------------|
| `int` | 64-bit signed integers | `int` | `42` | `42` |
| `uint` | 64-bit unsigned integers | `int` | `42u` | `42` |
| `double` | 64-bit IEEE floating-point | `float` | `3.14` | `3.14` |
| `bool` | Boolean values | `bool` | `true` | `True` |
| `string` | Unicode code point sequences | `str` | `"hello"` | `"hello"` |
| `bytes` | Byte sequences | `bytes` | `b"data"` | `b"data"` |
| `null_type` | Null value | `NoneType` | `null` | `None` |
| `list` | Ordered sequences | `list` | `[1, 2, 3]` | `[1, 2, 3]` |
| `map` | Key-value collections | `dict` | `{"key": "value"}` | `{"key": "value"}` |
| `timestamp` | Protocol buffer timestamps | `datetime.datetime` | `timestamp("2024-01-01T00:00:00Z")` | `datetime(2024, 1, 1, tzinfo=timezone.utc)` |
| `duration` | Protocol buffer durations | `datetime.timedelta` | `duration("1h30m")` | `timedelta(hours=1, minutes=30)` |

#### Map Type Constraints

**✅ FULLY COMPLIANT** with CEL specification:

- **Key Types**: Restricted to `int`, `uint`, `bool`, and `string` as per CEL spec
- **Value Types**: Support heterogeneous values (mixed types) as allowed by CEL spec
- **Runtime Behavior**: Maps can contain `dyn` types for mixed-value collections

**Examples:**
```cel
// ✅ Valid key types
{1: "int key", "str": "string key", true: "bool key"}

// ✅ Mixed value types (CEL compliant)
{"name": "Alice", "age": 30, "verified": true, "score": 95.5}

// ✅ Nested heterogeneous structures  
{"users": [{"name": "Alice"}, {"name": "Bob"}], "count": 2}
```

### Python to CEL Type Mapping

When passing Python objects as context:

| Python Type | CEL Type | Notes |
|-------------|----------|-------|
| `int` | `int` | Direct mapping |
| `float` | `double` | Direct mapping |
| `str` | `string` | Direct mapping |
| `bool` | `bool` | Direct mapping |
| `None` | `null` | Direct mapping |
| `list` | `list(T)` | Element types preserved |
| `dict` | `map(K, V)` | Key/value types preserved |
| `bytes` | `bytes` | Direct mapping |
| `datetime.datetime` | `timestamp` | Timezone info preserved |
| `datetime.timedelta` | `duration` | Direct mapping |

---

## Error Handling

### Exception Types

The library raises specific exception types for different error conditions based on the underlying error type:

#### `ValueError` - Parse and Compilation Errors

Raised when the CEL expression has invalid syntax, is empty, or fails to compile:

```python
from cel import evaluate

# Invalid syntax raises ValueError
try:
    evaluate("1 + + 2")  # Invalid syntax
    # → ValueError: Failed to compile expression: ...
    assert False, "Should have raised ValueError"
except ValueError as e:
    assert "Failed to compile expression" in str(e)

# Empty expression raises ValueError
try:
    evaluate("")
    # → ValueError: Invalid syntax or malformed expression
    assert False, "Should have raised ValueError"
except ValueError as e:
    assert "Invalid syntax" in str(e) or "malformed" in str(e)
```

#### `RuntimeError` - Variable and Function Errors

Raised for undefined variables or functions, and function execution errors:

```python
from cel import evaluate

# Undefined variables raise RuntimeError
try:
    evaluate("unknown_variable + 1", {})
    # → RuntimeError: Undefined variable 'unknown_variable'
    assert False, "Should have raised RuntimeError"
except RuntimeError as e:
    assert "Undefined variable" in str(e)

# Undefined functions raise RuntimeError
try:
    evaluate("unknownFunction(42)", {})
    # → RuntimeError: Undefined function 'unknownFunction'
    assert False, "Should have raised RuntimeError"
except RuntimeError as e:
    assert "Undefined" in str(e) and "function" in str(e)

# Function execution errors raise RuntimeError
from cel import Context
def failing_function():
    raise Exception("Something went wrong")

context = Context()
context.add_function("fail", failing_function)

try:
    evaluate("fail()", context)
    # → RuntimeError: Function 'fail' error: Something went wrong
    assert False, "Should have raised RuntimeError"
except RuntimeError as e:
    assert "Function 'fail' error" in str(e)
```

#### `TypeError` - Type Compatibility Errors

Raised when operations are performed on incompatible types:

```python
from cel import evaluate

# String + int operations raise TypeError
try:
    evaluate('"hello" + 42')  # String + int
    # → TypeError: Unsupported addition operation between string and int
    assert False, "Should have raised TypeError"
except TypeError as e:
    assert "Unsupported addition operation" in str(e)

# Mixed signed/unsigned int operations raise TypeError
try:
    evaluate("1u + 2")  # Mixed signed/unsigned int  
    # → TypeError: Cannot mix signed and unsigned integers
    assert False, "Should have raised TypeError"
except TypeError as e:
    assert "Cannot mix signed and unsigned integers" in str(e)

# Unsupported multiplication raises TypeError
try:
    evaluate('"text" * "more"')  # String multiplication
    # → TypeError: Unsupported multiplication operation between strings
    assert False, "Should have raised TypeError"
except TypeError as e:
    assert "Unsupported multiplication operation" in str(e)
```

#### Mixed Type Arithmetic Errors

**Mixed numeric types raise TypeError:**

```python
from cel import evaluate

# Mixed numeric types in expressions
try:
    evaluate("1 + 2.5")  # int + double
except TypeError as e:
    assert "Unsupported addition operation" in str(e)
    print(f"Mixed arithmetic error: {e}")

# Mixed types from context
context = {"int_val": 10, "float_val": 2.5}
try:
    evaluate("int_val * float_val", context)
except TypeError as e:
    assert "Unsupported multiplication operation" in str(e)
    print(f"Context type mixing error: {e}")

# To fix mixed arithmetic, use consistent types:
result = evaluate("1.0 + 2.5")  # → 3.5 (both doubles)
result = evaluate("1 + 2")      # → 3 (both ints)
```

### Production Error Handling

For comprehensive error handling patterns, safety guidelines, and production best practices, see the **[Error Handling How-To Guide](../how-to-guides/error-handling.md)** which covers:

- Safe handling of malformed expressions and untrusted input
- Safe evaluation wrappers and best practices
- Context validation patterns
- Defensive expression techniques
- Logging and monitoring
- Testing error scenarios